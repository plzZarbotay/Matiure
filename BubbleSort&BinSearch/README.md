# Описание программы

Эта программа представляет собой интерактивное приложение для работы с таблицей данных. Она позволяет пользователю заполнять таблицу как вручную, так и случайными данными, выполнять различные операции с таблицей, такие как сортировка, поиск, изменение порядка строк и т.д.

## Основные функции

1. **Заполнение таблицы**
   - Пользователь может заполнить таблицу вручную, указывая ключ и данные для каждой строки.
   - Есть возможность заполнения таблицы случайными данными.

2. **Операции с таблицей**
   - Очистка таблицы.
   - Сортировка таблицы по ключу.
   - Поиск строки по ключу.
   - Изменение порядка строк в таблице (переворот таблицы, перемешивание строк).

3. **Вывод таблицы**
   - Вывод содержимого таблицы на экран.

4. **Выход из программы**

## Описание алгоритмов

### 1. Заполнение таблицы
- Пользователю предоставляется возможность ввести количество строк таблицы.
- Далее пользователь вводит ключ и данные для каждой строки.
- Функция `add_row` добавляет новую строку в таблицу, проверяя уникальность ключа.
- Функция `add_random_row` добавляет случайные данные в таблицу, генерируя случайный ключ и случайные данные.

### 2. Операции с таблицей
- Очистка таблицы (`clean_table`) освобождает память, занятую таблицей, и создает новую пустую таблицу.
- Сортировка таблицы (`sort_table`) выполняется с использованием алгоритма сортировки пузырьком.
- Поиск строки по ключу (`binary_search`) осуществляется с помощью бинарного поиска в отсортированной таблице.
- Переворот таблицы (`reverse_table`) меняет порядок строк на обратный.
- Перемешивание строк таблицы (`mix_table`) происходит путем случайного обмена строк местами.

### 3. Вывод таблицы
- Функция `print_table` выводит содержимое таблицы на экран, выравнивая данные по столбцам.

## Примеры использования

1. **Заполнение таблицы вручную**:
   ```
   Menu:
   1. Fill table manually
   2. Fill table randomly
   3. Clear table
   4. Sort table
   5. Search by key
   6. Reverse table
   7. Mix table
   8. Print table
   9. Exit
   Input: 1

   Enter count of rows (<=12): 3
   Enter key: 101
   Enter data: Hello
   Enter key: 204
   Enter data: World
   Enter key: 303
   Enter data: This is a test

   Done
   ```

2. **Сортировка таблицы**:
   ```
   Menu:
   1. Fill table manually
   2. Fill table randomly
   3. Clear table
   4. Sort table
   5. Search by key
   6. Reverse table
   7. Mix table
   8. Print table
   9. Exit
   Input: 4

   Done
   ```

3. **Поиск строки по ключу**:
   ```
   Menu:
   1. Fill table manually
   2. Fill table randomly
   3. Clear table
   4. Sort table
   5. Search by key
   6. Reverse table
   7. Mix table
   8. Print table
   9. Exit
   Input: 5

   Key: 101
   Hello
   ```

4. **Вывод таблицы**:
   ```
   Menu:
   1. Fill table manually
   2. Fill table randomly
   3. Clear table
   4. Sort table
   5. Search by key
   6. Reverse table
   7. Mix table
   8. Print table
   9. Exit
   Input: 8

    | 101    | Hello         |
    | 204    | World         |
    | 303    | This is a test|
   ```

5. **Выход из программы**:
   ```
   Menu:
   1. Fill table manually
   2. Fill table randomly
   3. Clear table
   4. Sort table
   5. Search by key
   6. Reverse table
   7. Mix table
   8. Print table
   9. Exit
   Input: 9

   ```


# Подробное описание Binary Search:
Алгоритм бинарного поиска - это метод поиска значения в отсортированном массиве или списке. Он работает путем разделения массива на половины и последующего сужения диапазона поиска до тех пор, пока значение не будет найдено или пока не будет установлено, что значение отсутствует в массиве. 

### Описание алгоритма:

1. **Инициализация переменных**: Задаем начальные значения индексов для поиска. Обычно это левый (`low`) и правый (`high`) концы массива.

2. **Цикл**: Пока левый индекс меньше или равен правому, продолжаем поиск.

3. **Определение среднего индекса**: Вычисляем индекс середины массива, округляя вниз, если нечетное количество элементов.

4. **Сравнение значения**: Сравниваем искомое значение с элементом, находящимся в середине массива.
   - Если значение совпадает, возвращаем его индекс.
   - Если значение больше, чем элемент в середине, сужаем диапазон поиска до правой половины массива.
   - Если значение меньше, чем элемент в середине, сужаем диапазон поиска до левой половины массива.
   
5. **Повторяем шаги 3-4**: Повторяем процесс поиска в подмассиве, пока не будет найдено значение или пока диапазон поиска не сузится до пустого массива.

### Пример работы алгоритма:

Предположим, у нас есть отсортированный массив чисел `[2, 5, 7, 9, 12, 15, 17, 19, 22, 25]`, и мы хотим найти значение `12`.

1. **Инициализация**: Устанавливаем `low = 0` и `high = 9`, так как это индексы крайних элементов массива.

2. **Цикл**:
   - На первой итерации: `low = 0`, `high = 9`, индекс середины - `mid = 4`. Значение в `mid` равно `12`.
     - Так как `12` равно искомому значению, возвращаем индекс `4`.
   - Алгоритм завершается, так как значение найдено.

Алгоритм сортировки пузырьком (Bubble Sort) - это простой алгоритм сортировки, который многократно проходит по списку, сравнивая два соседних элемента и меняя их местами, если они находятся в неправильном порядке. По мере прохождения по списку, большие элементы "всплывают" к концу списка, а меньшие элементы "опускаются" к его началу.

Описание алгоритма:
Циклы: Повторяем процесс сортировки до тех пор, пока весь список не будет отсортирован. Это обычно делается с помощью внешнего и внутреннего циклов.

Внутренний цикл: Проходим по списку, сравнивая два соседних элемента.

Сравнение элементов: Если элемент на позиции i больше элемента на позиции i+1, меняем их местами.

Обмен элементов: После каждой итерации внутреннего цикла, самый большой элемент становится на свое место в конце списка.

Уменьшение диапазона: После каждой итерации внешнего цикла, диапазон сравнения уменьшается на один элемент в конце списка.

Повторение: Процесс повторяется до тех пор, пока весь список не будет отсортирован.

Пример работы алгоритма:
Предположим, у нас есть список [5, 3, 8, 4, 2], который нужно отсортировать в порядке возрастания.

Первая итерация:

Сравниваем 5 и 3. Так как 5 > 3, меняем их местами: [3, 5, 8, 4, 2].
Сравниваем 5 и 8. Элементы уже в правильном порядке.
Сравниваем 8 и 4. Так как 8 > 4, меняем их местами: [3, 5, 4, 8, 2].
Сравниваем 8 и 2. Так как 8 > 2, меняем их местами: [3, 5, 4, 2, 8].
После первой итерации наибольший элемент 8 переместился в конец списка.
Вторая итерация:

Повторяем процесс, начиная с начала списка, но уже без учета последнего элемента.
Сравниваем 3 и 5. Элементы уже в правильном порядке.
Сравниваем 5 и 4. Так как 5 > 4, меняем их местами: [3, 4, 5, 2, 8].
Сравниваем 5 и 2. Так как 5 > 2, меняем их местами: [3, 4, 2, 5, 8].
После второй итерации второй наибольший элемент 5 переместился на предпоследнюю позицию.
Третья и последующие итерации:

Процесс повторяется до тех пор, пока весь список не будет отсортирован.
Результат:
После завершения всех итераций, список становится [2, 3, 4, 5, 8], отсортированным в порядке возрастания.




